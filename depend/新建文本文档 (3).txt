


#include<stdlib.h>
#include<WINSOCK2.H>
 #include <windows.h> 
#include <process.h>  
 
#include<iostream>
#include<string>
using namespace std;
 
#define BUF_SIZE 64
#pragma comment(lib,"WS2_32.lib")
 
 
void recv(PVOID pt)  
{  
	    SOCKET  sHost=  *((SOCKET *)pt);
 
      	while(true)
		{
		    char buf[BUF_SIZE];//清空接收数据的缓冲区
			memset(buf,0 , BUF_SIZE);
			int retVal=recv(sHost,buf,sizeof(buf),0);
			if(SOCKET_ERROR==retVal)
			{
				int  err=WSAGetLastError();
				//无法立即完成非阻塞Socket上的操作
				if(err==WSAEWOULDBLOCK)
				{
					Sleep(1000);
					printf("\nwaiting  reply!");
					continue;
				}
				else if(err==WSAETIMEDOUT||err==WSAENETDOWN|| err==WSAECONNRESET)//已建立连接
				{
					printf("\nrecv failed!");
					closesocket(sHost);
					WSACleanup();
					return  ;
				}
 
			}
 
				Sleep(100);
 
	        	printf("\n%s", buf);
			 //break;
		} 
}  
 
 
int main()
{
	WSADATA wsd;
	SOCKET sHost;
	SOCKADDR_IN servAddr;//服务器地址
	int retVal;//调用Socket函数的返回值
	char buf[BUF_SIZE];
	//初始化Socket环境
	if(WSAStartup(MAKEWORD(2,2),&wsd)!=0)
	{
		printf("WSAStartup failed!\n");
		return -1;
	}
	sHost=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
	//设置服务器Socket地址
	servAddr.sin_family=AF_INET;
	servAddr.sin_addr.S_un.S_addr=inet_addr("127.0.0.1");
	//在实际应用中，建议将服务器的IP地址和端口号保存在配置文件中
	servAddr.sin_port=htons(6000);
	//计算地址的长度
	int sServerAddlen=sizeof(servAddr);
	
	
	
 	//调用ioctlsocket（）将其设置为非阻塞模式
   int iMode=1;
	retVal=ioctlsocket(sHost,FIONBIO,(u_long FAR*)&iMode); 
	
	
	if(retVal==SOCKET_ERROR)
	{
		printf("ioctlsocket failed!");
		WSACleanup();
		return -1;
	}
	
	
	//循环等待
	while(true)
	{
		//连接到服务器
		retVal=connect(sHost,(LPSOCKADDR)&servAddr,sizeof(servAddr));
		if(SOCKET_ERROR==retVal)
		{
			int err=WSAGetLastError();
			//无法立即完成非阻塞Socket上的操作
			if(err==WSAEWOULDBLOCK||err==WSAEINVAL)
			{
				Sleep(1);
				printf("check  connect!\n");
				continue;
			}
			else if(err==WSAEISCONN)//已建立连接
			{
				break;
			}
			else
			{
				printf("connection failed!\n");
				closesocket(sHost);
				WSACleanup();
				return -1;
			}
		}
	}
	
	
    unsigned long     threadId=_beginthread(recv,0,&sHost);//启动一个线程接收数据的线程   
 
 
	
	while(true)
	{
		//向服务器发送字符串，并显示反馈信息
		printf("input a string to send:\n");
		std::string str;
		//接收输入的数据
		std::cin>>str;
		//将用户输入的数据复制到buf中
		ZeroMemory(buf,BUF_SIZE);
		strcpy(buf,str.c_str());
		if(strcmp(buf,"quit")==0)
		{
			printf("quit!\n");
			break;
		}
		
		while(true)
		{
			retVal=send(sHost,buf,strlen(buf),0);
			if(SOCKET_ERROR==retVal)
			{
				int err=WSAGetLastError();
				if(err==WSAEWOULDBLOCK)
				{
					//无法立即完成非阻塞Socket上的操作
					Sleep(5);
					continue;
				}
				
				else
				{
					printf("send failed!\n");
					closesocket(sHost);
					WSACleanup();
					return -1;
				}
			}
			break;
		}
		  
		
	}
	
	return 0;
}

————————————————
版权声明：本文为CSDN博主「AncientCastle」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/hq354974212/article/details/76154849